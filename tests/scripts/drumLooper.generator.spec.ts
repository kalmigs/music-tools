import { mkdtemp, mkdir, readFile, writeFile } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import path from 'node:path';

import { describe, expect, it } from 'vitest';

import { buildManifest, createSource, generate } from '../../scripts/drumLooper.generator';

describe('drumLooper.generator', () => {
  it('buildManifest groups files by kit and picks starter samples by first sorted item per group', () => {
    const rootDir = '/repo/public/drum-looper';
    const files = [
      '/repo/public/drum-looper/Kit A/Kicks/kick 2.wav',
      '/repo/public/drum-looper/Kit A/Kicks/kick 1.wav',
      '/repo/public/drum-looper/Kit A/Snares/snare 1.wav',
      '/repo/public/drum-looper/Kit A/readme.txt',
      '/repo/public/drum-looper/Kit B/Loops/loop 1.mp3',
    ];

    const kits = buildManifest(files, rootDir);

    expect(kits).toHaveLength(2);

    const kitA = kits.find(kit => kit.id === 'kit-a');
    expect(kitA).toBeDefined();
    expect(kitA?.samples.map(sample => sample.path)).toEqual([
      '/drum-looper/Kit A/Kicks/kick 1.wav',
      '/drum-looper/Kit A/Kicks/kick 2.wav',
      '/drum-looper/Kit A/Snares/snare 1.wav',
    ]);
    expect(kitA?.starterSamples.map(sample => `${sample.group}:${sample.path}`)).toEqual([
      'Kicks:/drum-looper/Kit A/Kicks/kick 1.wav',
      'Snares:/drum-looper/Kit A/Snares/snare 1.wav',
    ]);

    const kitB = kits.find(kit => kit.id === 'kit-b');
    expect(kitB?.samples).toHaveLength(1);
    expect(kitB?.samples[0]?.path).toBe('/drum-looper/Kit B/Loops/loop 1.mp3');
  });

  it('createSource emits the generated header and exported drumKits payload', () => {
    const source = createSource([
      {
        id: 'kit-a',
        name: 'Kit A',
        samples: [],
        starterSamples: [],
      },
    ]);

    expect(source).toContain('// Generated by scripts/drumLooper.generator.ts');
    expect(source).toContain('export const drumKits: DrumKitManifest[] = [');
    expect(source).toContain('"id": "kit-a"');
  });

  it('generate writes output file from a real directory tree', async () => {
    const sandbox = await mkdtemp(path.join(tmpdir(), 'drum-generator-'));
    const rootDir = path.join(sandbox, 'public', 'drum-looper');
    const outputFile = path.join(sandbox, 'src', 'drumLooper.gen.ts');

    await mkdir(path.join(rootDir, 'LoFi Kit', 'Kicks'), { recursive: true });
    await mkdir(path.join(rootDir, 'LoFi Kit', 'Snares'), { recursive: true });
    await writeFile(path.join(rootDir, 'LoFi Kit', 'Kicks', 'kick 1.wav'), '');
    await writeFile(path.join(rootDir, 'LoFi Kit', 'Snares', 'snare 1.wav'), '');

    await generate({ rootDir, outputFile });

    const generated = await readFile(outputFile, 'utf8');
    expect(generated).toContain('export const drumKits: DrumKitManifest[] = [');
    expect(generated).toContain('"id": "lofi-kit"');
    expect(generated).toContain('/drum-looper/LoFi Kit/Kicks/kick 1.wav');
    expect(generated).toContain('/drum-looper/LoFi Kit/Snares/snare 1.wav');
  });

  it('generate writes an empty manifest when rootDir does not exist', async () => {
    const sandbox = await mkdtemp(path.join(tmpdir(), 'drum-generator-empty-'));
    const rootDir = path.join(sandbox, 'does-not-exist');
    const outputFile = path.join(sandbox, 'src', 'drumLooper.gen.ts');

    await generate({ rootDir, outputFile });

    const generated = await readFile(outputFile, 'utf8');
    expect(generated).toContain('export const drumKits: DrumKitManifest[] = [];');
  });

  it('buildManifest ignores non-audio files and keeps root-level kit samples', () => {
    const rootDir = '/repo/public/drum-looper';
    const files = [
      '/repo/public/drum-looper/README.md',
      '/repo/public/drum-looper/Kit A/kick.wav',
      '/repo/public/drum-looper/Kit A/Kicks/kick.wav',
      '/repo/public/drum-looper/Kit A/Kicks/kick.txt',
    ];

    const kits = buildManifest(files, rootDir);

    expect(kits).toHaveLength(1);
    expect(kits[0]?.samples.map(sample => sample.path)).toEqual([
      '/drum-looper/Kit A/kick.wav',
      '/drum-looper/Kit A/Kicks/kick.wav',
    ]);
    expect(kits[0]?.samples.map(sample => sample.group)).toEqual(['root', 'Kicks']);
  });
});
