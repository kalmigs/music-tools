import { promises as fs } from 'node:fs';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

interface DrumKitManifestItem {
  group: string;
  id: string;
  kit: string;
  name: string;
  path: string;
}

interface DrumKitManifest {
  id: string;
  name: string;
  samples: DrumKitManifestItem[];
  starterSamples: DrumKitManifestItem[];
}

const AUDIO_EXTENSIONS = new Set(['.wav', '.mp3', '.ogg', '.m4a', '.flac', '.aac']);
const DEFAULT_ROOT_DIR = path.resolve(process.cwd(), 'public/drum-looper');
const DEFAULT_OUTPUT_FILE = path.resolve(process.cwd(), 'src/drumLooper.gen.ts');

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

function toId(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

function toTitleCase(value: string): string {
  return value
    .split(/[-_\s]+/)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

export async function walkDirectory(dirPath: string, files: string[] = []): Promise<string[]> {
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);

    if (entry.isDirectory()) {
      await walkDirectory(fullPath, files);
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }

  return files;
}

export function buildManifest(filePaths: string[], rootDir = DEFAULT_ROOT_DIR): DrumKitManifest[] {
  const kits = new Map<string, DrumKitManifest>();

  for (const filePath of filePaths) {
    const extension = path.extname(filePath).toLowerCase();
    if (!AUDIO_EXTENSIONS.has(extension)) {
      continue;
    }

    const relativeToRoot = path.relative(rootDir, filePath);
    const segments = relativeToRoot.split(path.sep).filter(Boolean);

    if (segments.length < 2) {
      continue;
    }

    const kitFolder = segments[0];
    const relativeWithinKit = segments.slice(1).join('/');
    const sampleGroup = segments.length > 2 ? segments[1] : 'root';
    const sampleBaseName = path.basename(relativeWithinKit, extension);

    const kitId = toId(kitFolder);
    const kitName = toTitleCase(kitFolder);
    const sampleId = toId(`${kitFolder}-${relativeWithinKit}`);
    const sampleName = toTitleCase(sampleBaseName);
    const publicPath = `/drum-looper/${segments.join('/')}`;

    if (!kits.has(kitId)) {
      kits.set(kitId, {
        id: kitId,
        name: kitName,
        samples: [],
        starterSamples: [],
      });
    }

    kits.get(kitId)?.samples.push({
      group: sampleGroup,
      id: sampleId,
      kit: kitId,
      name: sampleName,
      path: publicPath,
    });
  }

  return [...kits.values()]
    .map(kit => {
      const sortedSamples = [...kit.samples].sort((a, b) => a.path.localeCompare(b.path));
      const firstByGroup = new Map<string, DrumKitManifestItem>();

      for (const sample of sortedSamples) {
        if (!firstByGroup.has(sample.group)) {
          firstByGroup.set(sample.group, sample);
        }
      }

      return {
        ...kit,
        samples: sortedSamples,
        starterSamples: [...firstByGroup.values()].sort((a, b) => a.path.localeCompare(b.path)),
      };
    })
    .sort((a, b) => a.name.localeCompare(b.name));
}

export function createSource(kits: DrumKitManifest[]): string {
  const payload = JSON.stringify(kits, null, 2);

  return `/* eslint-disable */\n// @ts-nocheck\n// Generated by scripts/drumLooper.generator.ts\n\nexport interface DrumKitManifestItem {\n  group: string;\n  id: string;\n  kit: string;\n  name: string;\n  path: string;\n}\n\nexport interface DrumKitManifest {\n  id: string;\n  name: string;\n  samples: DrumKitManifestItem[];\n  starterSamples: DrumKitManifestItem[];\n}\n\nexport const drumKits: DrumKitManifest[] = ${payload};\n`;
}

async function ensureOutputDirectory(outputFile: string): Promise<void> {
  await fs.mkdir(path.dirname(outputFile), { recursive: true });
}

export async function generate(options?: { rootDir?: string; outputFile?: string }): Promise<void> {
  const rootDir = options?.rootDir ?? DEFAULT_ROOT_DIR;
  const outputFile = options?.outputFile ?? DEFAULT_OUTPUT_FILE;
  const rootExists = await fileExists(rootDir);

  let kits: DrumKitManifest[] = [];

  if (rootExists) {
    const allFiles = await walkDirectory(rootDir);
    kits = buildManifest(allFiles, rootDir);
  }

  await ensureOutputDirectory(outputFile);
  await fs.writeFile(outputFile, createSource(kits), 'utf8');

  console.log(`Generated ${path.relative(process.cwd(), outputFile)} with ${kits.length} kits.`);
}

if (process.argv[1] && path.resolve(process.argv[1]) === fileURLToPath(import.meta.url)) {
  generate().catch(error => {
    console.error(error);
    process.exit(1);
  });
}
